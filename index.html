import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { 
  Dna, 
  Brain, 
  Bone, 
  Activity, 
  Play, 
  Check, 
  X, 
  Trophy, 
  Flame, 
  Siren, 
  Loader2,
  RefreshCw,
  Trash2,
  Smile
} from 'lucide-react';

// --- CONFIG & DATA ---
const apiKey = ""; // Injected by runtime environment

const BONES = [
  { nl: "Bovenbeen", la: "Femur" },
  { nl: "Scheenbeen", la: "Tibia" },
  { nl: "Kuitbeen", la: "Fibula" },
  { nl: "Opperarmbeen", la: "Humerus" },
  { nl: "Spaakbeen", la: "Radius" },
  { nl: "Ellepijp", la: "Ulna" },
  { nl: "Sleutelbeen", la: "Clavicula" },
  { nl: "Schouderblad", la: "Scapula" },
  { nl: "Borstbeen", la: "Sternum" },
  { nl: "Bekken", la: "Pelvis" },
  { nl: "Schedel", la: "Cranium" },
  { nl: "Wervelkolom", la: "Vertebrae" },
  { nl: "Knieschijf", la: "Patella" }
];

const MUSCLES = [
  { nl: "Borstspier", la: "Pectoralis Major" },
  { nl: "Schouderspier", la: "Deltoideus" },
  { nl: "Brede rugspier", la: "Latissimus Dorsi" },
  { nl: "Monnikskapspier", la: "Trapezius" },
  { nl: "Grote bilspier", la: "Gluteus Maximus" },
  { nl: "Lange rugspier", la: "Erector Spinae" },
  { nl: "Rechte buikspier", la: "Rectus Abdominis" },
  { nl: "Schuine buikspier", la: "Obliquus Abdominis" },
  { nl: "Arm buiger", la: "Biceps brachii" },
  { nl: "Vierhoofdige dijbeenspier", la: "Quadriceps Femoris" },
  { nl: "Hamstrings", la: "Biceps Femoris" },
  { nl: "Kuitspieren", la: "Triceps Surae" },
  { nl: "Armstrekker", la: "Triceps Brachii" }
];

// --- CONFETTI ENGINE (Custom Canvas) ---
const ConfettiCanvas = ({ active, onClickTrigger }: { active: boolean, onClickTrigger?: boolean }) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const particles = useRef<any[]>([]);
  const animationFrame = useRef<number>();

  const colors = ['#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#6366F1', '#8B5CF6', '#EC4899'];

  const createParticle = (x: number, y: number, burst: boolean) => {
    const angle = Math.random() * Math.PI * 2;
    const velocity = burst ? 10 + Math.random() * 20 : 2 + Math.random() * 5;
    return {
      x,
      y,
      vx: Math.cos(angle) * velocity,
      vy: Math.sin(angle) * velocity - (burst ? 5 : 0),
      color: colors[Math.floor(Math.random() * colors.length)],
      size: Math.random() * 8 + 4,
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 10,
      gravity: 0.5,
      drag: 0.95,
      life: 1.0,
      decay: Math.random() * 0.01 + 0.005
    };
  };

  const spawnBurst = (x: number, y: number) => {
    for (let i = 0; i < 50; i++) {
      particles.current.push(createParticle(x, y, true));
    }
  };

  useEffect(() => {
    if (!active) return;

    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Initial Burst
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;

    // Massive initial explosion
    for(let i=0; i<5; i++) {
        setTimeout(() => spawnBurst(w/2 + (Math.random() * 400 - 200), h/2 + (Math.random() * 200 - 100)), i * 200);
    }

    const render = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Auto spawn some from top
      if (Math.random() < 0.1) {
          particles.current.push(createParticle(Math.random() * canvas.width, -20, false));
      }

      particles.current.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity;
        p.vx *= p.drag;
        p.vy *= p.drag;
        p.rotation += p.rotationSpeed;
        p.life -= p.decay;

        if (p.life <= 0 || p.y > canvas.height + 100) {
          particles.current.splice(i, 1);
          return;
        }

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate((p.rotation * Math.PI) / 180);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        ctx.restore();
      });

      animationFrame.current = requestAnimationFrame(render);
    };

    render();

    const handleResize = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    };
    window.addEventListener('resize', handleResize);

    const handleClick = (e: MouseEvent) => {
        spawnBurst(e.clientX, e.clientY);
    };
    if (onClickTrigger) {
        window.addEventListener('mousedown', handleClick);
    }

    return () => {
      if (animationFrame.current) cancelAnimationFrame(animationFrame.current);
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('mousedown', handleClick);
    };
  }, [active, onClickTrigger]);

  if (!active) return null;
  return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-[100]" />;
};

// --- AUDIO ENGINE ---
class AudioService {
  ctx: AudioContext | null = null;

  init() {
    if (!this.ctx) {
      this.ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
    }
    if (this.ctx.state === 'suspended') {
      this.ctx.resume();
    }
  }

  playTone(freq: number, type: OscillatorType, duration: number, vol = 0.1) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    osc.type = type;
    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
    
    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  }

  playCorrect() {
    this.init();
    this.playTone(660, 'sine', 0.1);
    setTimeout(() => this.playTone(880, 'sine', 0.2), 100);
  }

  playWrong() {
    this.init();
    this.playTone(150, 'sawtooth', 0.3, 0.2);
  }

  playStreak(streak: number) {
    this.init();
    if (streak === 3) { // Major Triad
      this.playTone(440, 'triangle', 0.3); // A4
      setTimeout(() => this.playTone(554, 'triangle', 0.3), 100); // C#5
      setTimeout(() => this.playTone(659, 'triangle', 0.4), 200); // E5
    } else if (streak === 5) { // Fast High Arpeggio
      [523, 659, 783, 1046].forEach((freq, i) => {
        setTimeout(() => this.playTone(freq, 'square', 0.2, 0.1), i * 80);
      });
    } else if (streak === 8) { // Siren
      this.playSiren();
    }
  }

  playSiren() {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(440, this.ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(880, this.ctx.currentTime + 0.3);
    osc.frequency.linearRampToValueAtTime(440, this.ctx.currentTime + 0.6);
    
    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.6);

    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + 0.6);
  }

  playMeltdown() {
    if (!this.ctx) return;
    const t = this.ctx.currentTime;

    // 1. Sticky Dripping Sounds (Randomized pings with pitch drop)
    const dripTimes = [0.8, 1.5, 2.2, 2.4, 2.9, 3.2, 3.8];
    dripTimes.forEach(dt => {
       const osc = this.ctx!.createOscillator();
       const gain = this.ctx!.createGain();
       
       // High start frequency dropping fast -> "Plop" sound
       osc.frequency.setValueAtTime(800 + Math.random() * 400, t + dt);
       osc.frequency.exponentialRampToValueAtTime(200, t + dt + 0.05);
       
       gain.gain.setValueAtTime(0, t + dt);
       gain.gain.linearRampToValueAtTime(0.2, t + dt + 0.01);
       gain.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.1);

       osc.connect(gain);
       gain.connect(this.ctx!.destination);
       osc.start(t + dt);
       osc.stop(t + dt + 0.15);
    });

    // 2. Low Bass Rumble (Building ominous tension)
    const rumbleOsc = this.ctx.createOscillator();
    const rumbleGain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    rumbleOsc.type = 'sawtooth';
    rumbleOsc.frequency.setValueAtTime(50, t);
    rumbleOsc.frequency.linearRampToValueAtTime(30, t + 5); 
    
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(120, t);
    filter.frequency.linearRampToValueAtTime(60, t + 5);

    rumbleGain.gain.setValueAtTime(0, t);
    rumbleGain.gain.linearRampToValueAtTime(0, t + 1); // Delay start slightly
    rumbleGain.gain.linearRampToValueAtTime(0.5, t + 4.5); // Build up loud
    rumbleGain.gain.linearRampToValueAtTime(0, t + 6); // Fade out after thud

    rumbleOsc.connect(filter);
    filter.connect(rumbleGain);
    rumbleGain.connect(this.ctx.destination);
    rumbleOsc.start(t);
    rumbleOsc.stop(t + 6);

    // 3. Heavy Muffled Thud (Sealed Shut)
    const thudTime = t + 4.8;
    const thudOsc = this.ctx.createOscillator();
    const thudGain = this.ctx.createGain();
    const thudFilter = this.ctx.createBiquadFilter();
    
    thudOsc.type = 'square';
    thudOsc.frequency.setValueAtTime(80, thudTime);
    thudOsc.frequency.exponentialRampToValueAtTime(10, thudTime + 0.4);

    thudFilter.type = 'lowpass';
    thudFilter.frequency.value = 150; // Very muffled

    thudGain.gain.setValueAtTime(0, thudTime);
    thudGain.gain.linearRampToValueAtTime(0.8, thudTime + 0.02); // Sharp attack
    thudGain.gain.exponentialRampToValueAtTime(0.001, thudTime + 0.8);

    thudOsc.connect(thudFilter);
    thudFilter.connect(thudGain);
    thudGain.connect(this.ctx.destination);
    thudOsc.start(thudTime);
    thudOsc.stop(thudTime + 1);
  }

  playFanfare() {
    if (!this.ctx) return;
    const notes = [523, 523, 523, 659, 783, 1046];
    const timings = [0, 150, 300, 450, 600, 900];
    notes.forEach((n, i) => {
        setTimeout(() => this.playTone(n, 'triangle', 0.4, 0.2), timings[i]);
    });
  }
}

const audio = new AudioService();

// --- UTILS ---

const levenshtein = (a: string, b: string): number => {
  const matrix = Array.from({ length: a.length + 1 }, () => Array(b.length + 1).fill(0));
  for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
  for (let j = 0; j <= b.length; j++) matrix[0][j] = j;

  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      );
    }
  }
  return matrix[a.length][b.length];
};

const getDutchGrade = (correct: number, total: number) => {
  const percentage = (correct / total) * 100;
  let grade = 0;
  if (percentage < 65) {
    grade = 1 + (percentage / 65) * 4.5;
  } else {
    grade = 5.5 + ((percentage - 65) / 35) * 4.5;
  }
  return Math.min(10, Math.max(1, grade)).toFixed(1);
};

const getGradeText = (grade: number) => {
  if (grade < 2.0) return "Hele zware Onvoldoende";
  if (grade < 3.0) return "Zware onvoldoende";
  if (grade < 4.0) return "Dikke onvoldoende";
  if (grade < 5.5) return "Onvoldoende";
  if (grade < 7.0) return "Voldoende";
  if (grade < 8.0) return "Ruim voldoende";
  if (grade < 9.0) return "Goed";
  if (grade < 10) return "Zeer goed";
  return "Uitmuntend!";
};

const getFeedbackQuote = (grade: number) => {
  if (grade < 4) return "Mwoap, mwoap, mwoawawaaaoop. Behoorlijk slecht dit";
  if (grade < 5.5) return "Jammer, volgende keer lukt het je, weet ik zeker";
  if (grade < 7) return "Voldoende! Hier ben je vast blij mee, ik denk dat een 8+ er voor jou zeker in zit!";
  if (grade < 9) return "Wauw wat goeeeeeed! Zo trots op jou!";
  if (grade < 10) return "Jij bent uitmuntend, gewoon uitmuntend";
  // Fixed capitalization below
  return "Ik ben voor je gesmolten, niemand is beter dan jij en iedereen wil jou zijn.";
};

const getThemeColors = (level: string) => {
  switch (level) {
    case 'beginner': return { bg: 'bg-green-500', text: 'text-green-900', button: 'bg-green-700 hover:bg-green-600', lightBg: 'bg-green-50', border: 'border-green-900' };
    case 'advanced': return { bg: 'bg-blue-500', text: 'text-blue-900', button: 'bg-blue-700 hover:bg-blue-600', lightBg: 'bg-blue-50', border: 'border-blue-900' };
    case 'specialist': return { bg: 'bg-red-500', text: 'text-red-900', button: 'bg-red-700 hover:bg-red-600', lightBg: 'bg-red-50', border: 'border-red-900' };
    case 'expert': return { bg: 'bg-gray-900', text: 'text-gray-900', button: 'bg-black hover:bg-gray-800', lightBg: 'bg-gray-100', border: 'border-black' };
    default: return { bg: 'bg-orange-500', text: 'text-indigo-900', button: 'bg-indigo-900 hover:bg-indigo-800', lightBg: 'bg-indigo-50', border: 'border-indigo-900' };
  }
};

// --- COMPONENTS ---

const Sticker = ({ type, visible }: { type: 'hot' | 'super' | 'lava', visible: boolean }) => {
  if (!visible) return null;
  const styles = {
    hot: "bg-yellow-400 text-yellow-900 rotate-12",
    super: "bg-orange-500 text-white -rotate-6 scale-110",
    lava: "bg-red-600 text-white rotate-3 scale-125 animate-pulse border-4 border-yellow-300"
  };
  const icons = {
    hot: <span className="flex items-center gap-1">HOT STREAK! <Flame size={20}/></span>,
    super: <span className="flex items-center gap-1">SUPER HOT! <Flame size={20} fill="white"/><Flame size={20} fill="white"/></span>,
    lava: <span className="flex items-center gap-1">LAVA HOT! <Siren size={24} className="animate-spin"/></span>
  };
  return (
    <div className={`absolute -top-4 -right-4 px-4 py-2 shadow-xl font-black rounded-lg transform transition-all duration-300 z-50 ${styles[type]}`}>
      {icons[type]}
    </div>
  );
};

const AchievementSticker = () => (
    <div className="absolute top-1/2 -right-4 transform -translate-y-1/2 rotate-12 bg-orange-400 text-white px-3 py-1 rounded-full shadow-lg border-2 border-white z-20 flex items-center gap-1 animate-in zoom-in">
        <span className="font-black text-xs uppercase">Behaald!</span>
        <Smile size={16} fill="white" className="text-orange-500"/>
    </div>
);

const LavaOverlay = ({ active }: { active: boolean }) => {
  if (!active) return null;
  const numDrips = 12; // More drips for thicker coverage
  
  const drips = useMemo(() => {
    return Array.from({ length: numDrips }).map((_, i) => {
      // Slower, heavier movement
      const duration = 4 + Math.random() * 1.5; 
      const delay = Math.random() * 1.0;
      const width = 15 + Math.random() * 20 + '%';
      const startX = (i / numDrips) * 100 + (Math.random() * 10 - 5);
      
      const keyframeName = `lava-drip-${i}`;
      
      return {
        key: i,
        style: {
          position: 'absolute' as const,
          top: '-20%', 
          left: `${startX}%`, 
          width: width, 
          height: '140%', 
          // Glossy Red Paint Gradient
          background: 'linear-gradient(90deg, #991b1b 0%, #dc2626 40%, #ef4444 50%, #dc2626 60%, #991b1b 100%)',
          borderRadius: '0 0 150px 150px',
          boxShadow: 'inset 0 -10px 20px rgba(0,0,0,0.3), 0 10px 20px rgba(0,0,0,0.4)',
          animation: `${keyframeName} ${duration}s cubic-bezier(0.4, 0.0, 0.2, 1) forwards`,
          animationDelay: `${1 + delay}s`, // Wait for initial freeze
          opacity: 1, 
          zIndex: 60, 
        },
        highlightStyle: {
            position: 'absolute' as const,
            top: '20%',
            left: '20%',
            width: '10%',
            height: '40%',
            background: 'linear-gradient(to bottom, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 100%)',
            borderRadius: '50px',
            opacity: 0.6,
            filter: 'blur(2px)'
        },
        keyframe: `@keyframes ${keyframeName} { 
            0% { transform: translateY(-100%); } 
            100% { transform: translateY(100%); } 
        }`
      };
    });
  }, [numDrips]);

  return (
    <div className="fixed inset-0 z-50 pointer-events-none overflow-hidden">
      <style>{drips.map(d => d.keyframe).join('\n')}</style>
      
      {/* Background fill that follows slightly behind to ensure full coverage */}
      <div 
        className="absolute inset-0 bg-[#7f1d1d] z-50"
        style={{
            animation: 'fill-screen 5s ease-in-out forwards',
            animationDelay: '1s' // Wait for freeze
        }}
      >
        <style>{`
            @keyframes fill-screen {
                0% { opacity: 0; transform: translateY(-100%); }
                40% { opacity: 0.8; transform: translateY(-50%); }
                100% { opacity: 1; transform: translateY(0%); }
            }
        `}</style>
      </div>

      {drips.map(drip => (
        <div key={drip.key} style={drip.style}>
             {/* Glossy Highlight */}
            <div style={drip.highlightStyle}></div>
        </div>
      ))}
    </div>
  );
};

export default function App() {
  const [screen, setScreen] = useState<'setup' | 'quiz' | 'meltdown' | 'result'>('setup');
  const [logoUrl, setLogoUrl] = useState<string | null>(localStorage.getItem('dutch_anatomy_logo'));
  const [isGeneratingLogo, setIsGeneratingLogo] = useState(false);
  
  // Progress State
  const [achievements, setAchievements] = useState(() => {
    const saved = localStorage.getItem('dutch_anatomy_achievements');
    return saved ? JSON.parse(saved) : { beginner: false, advanced: false, specialist: false, expert: false };
  });

  const [topic, setTopic] = useState<'bones' | 'muscles'>('bones');
  const [count, setCount] = useState(10);
  const [level, setLevel] = useState<'beginner' | 'advanced' | 'specialist' | 'expert'>('beginner');

  const [questions, setQuestions] = useState<any[]>([]);
  const [currentIdx, setCurrentIdx] = useState(0);
  const [score, setScore] = useState(0);
  const [streak, setStreak] = useState(0);
  const [inputVal, setInputVal] = useState('');
  const [showFeedback, setShowFeedback] = useState<'correct' | 'wrong' | null>(null);
  const [options, setOptions] = useState<any[]>([]);
  const [isMelting, setIsMelting] = useState(false);

  const theme = getThemeColors(level);
  
  // Check if ALL levels are achieved
  const allLevelsCompleted = Object.values(achievements).every(Boolean);

  // Trigger confetti when returning to setup screen if all completed
  const [showConfetti, setShowConfetti] = useState(false);

  useEffect(() => {
    if (allLevelsCompleted && screen === 'setup') {
        setShowConfetti(true);
    } else {
        setShowConfetti(false);
    }
  }, [allLevelsCompleted, screen]);

  // Logo Generation
  useEffect(() => {
    if (!logoUrl && !isGeneratingLogo) {
      generateLogo();
    }
  }, []);

  const generateLogo = async () => {
    setIsGeneratingLogo(true);
    try {
      const prompt = "A 3D render of a cute cartoon human character standing in a heroic pose flexing both biceps. The character is split vertically: left side skeleton, right side muscles without skin.";
      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            instances: [{ prompt }],
            parameters: { sampleCount: 1 }
          })
        }
      );
      const data = await response.json();
      if (data.predictions && data.predictions[0]) {
        const base64 = `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`;
        setLogoUrl(base64);
        localStorage.setItem('dutch_anatomy_logo', base64);
      }
    } catch (e) {
      console.error("Logo generation failed", e);
    } finally {
      setIsGeneratingLogo(false);
    }
  };

  const startQuiz = () => {
    audio.init();
    const source = topic === 'bones' ? BONES : MUSCLES;
    const shuffled = [...source].sort(() => 0.5 - Math.random());
    const selected = shuffled.slice(0, count);
    
    setQuestions(selected);
    setCurrentIdx(0);
    setScore(0);
    setStreak(0);
    setInputVal('');
    setShowFeedback(null);
    setIsMelting(false);
    prepareOptions(selected[0], source);
    setScreen('quiz');
  };

  const prepareOptions = (correct: any, all: any[]) => {
    if (level === 'expert' || level === 'specialist') {
      setOptions([]);
      return;
    }
    const distractors = all
      .filter(i => i.la !== correct.la)
      .sort(() => 0.5 - Math.random())
      .slice(0, 3);
    const set = [...distractors, correct].sort(() => 0.5 - Math.random());
    setOptions(set);
  };

  const handleAnswer = (answer: string) => {
    if (showFeedback) return;
    const currentQ = questions[currentIdx];
    let isCorrect = false;

    if (level === 'expert') {
      const normalizedInput = answer.toLowerCase().trim();
      const normalizedTarget = currentQ.la.toLowerCase().trim();
      const dist = levenshtein(normalizedInput, normalizedTarget);
      isCorrect = dist <= 1;
    } else if (level === 'specialist') {
      const normalizedInput = answer.toLowerCase().trim();
      const normalizedTarget = currentQ.nl.toLowerCase().trim();
      const dist = levenshtein(normalizedInput, normalizedTarget);
      isCorrect = dist <= 1;
    } else if (level === 'advanced') {
        isCorrect = answer === currentQ.la;
    } else {
        isCorrect = answer === currentQ.nl;
    }

    if (isCorrect) {
      setScore(s => s + 1);
      const newStreak = streak + 1;
      setStreak(newStreak);
      audio.playCorrect();
      if (newStreak === 3 || newStreak === 5 || newStreak === 8) {
        setTimeout(() => audio.playStreak(newStreak), 400);
      }
      setShowFeedback('correct');
      if (newStreak === 10) {
        setTimeout(() => triggerMeltdown(), 1000);
        return;
      }
    } else {
      setStreak(0);
      audio.playWrong();
      setShowFeedback('wrong');
    }

    setTimeout(() => {
      if (currentIdx + 1 < questions.length) {
        setCurrentIdx(prev => prev + 1);
        prepareOptions(questions[currentIdx + 1], topic === 'bones' ? BONES : MUSCLES);
        setShowFeedback(null);
        setInputVal('');
      } else {
        finishQuiz();
      }
    }, 1500);
  };

  const triggerMeltdown = () => {
    setIsMelting(true);
    setScreen('meltdown');
    audio.playMeltdown();
    // Extended duration for cinematic effect (5s total)
    setTimeout(() => {
       finishQuiz(true);
    }, 5000); 
  };

  const finishQuiz = (melted = false) => {
    setScreen('result');
    if (!melted && !isMelting) audio.playFanfare();
    
    // Check for achievements
    const finalScore = score; 
    const grade = parseFloat(getDutchGrade(finalScore, count));
    
    if (grade >= 8.0) {
        const newAchievements = { ...achievements, [level]: true };
        setAchievements(newAchievements);
        localStorage.setItem('dutch_anatomy_achievements', JSON.stringify(newAchievements));
    }
  };

  const resetProgress = () => {
      const reset = { beginner: false, advanced: false, specialist: false, expert: false };
      setAchievements(reset);
      localStorage.setItem('dutch_anatomy_achievements', JSON.stringify(reset));
      setShowConfetti(false);
  };

  // --- RENDERERS ---

  if (screen === 'setup') {
    return (
      <div className={`min-h-screen ${theme.bg} transition-colors duration-500 flex items-center justify-center p-4 font-sans relative`}>
        {/* Victory Confetti Layer - Clicking triggers more */}
        <ConfettiCanvas active={showConfetti} onClickTrigger={true} />

        <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md w-full text-center relative overflow-hidden z-10">
          <div className="mb-6 flex justify-center">
            {logoUrl ? (
              <img src={logoUrl} alt="Logo" className={`w-32 h-32 object-cover rounded-full border-4 ${theme.border} shadow-lg transition-colors`} />
            ) : (
              <div className={`w-32 h-32 rounded-full ${theme.lightBg} flex items-center justify-center animate-pulse border-4 border-white`}>
                <Loader2 className={`w-10 h-10 ${theme.text.replace('text-', 'text-opacity-50 ')} animate-spin`} />
              </div>
            )}
          </div>

          <h1 className={`text-3xl font-black ${theme.text} mb-2 tracking-tight transition-colors`}>Anatomie Trainer</h1>
          {allLevelsCompleted ? (
              <p className="text-orange-500 font-bold mb-8 text-lg animate-pulse">GEFELICITEERD! JE BENT EEN MEESTER! üéâ</p>
          ) : (
              <p className="text-gray-500 mb-8 text-sm font-medium">Master the body, melt this quiz!</p>
          )}

          <div className="space-y-4 text-left">
            <div>
              <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Onderwerp</label>
              <div className="grid grid-cols-2 gap-2">
                <button onClick={() => setTopic('bones')} className={`p-3 rounded-xl font-bold border-2 transition-all ${topic === 'bones' ? `${theme.border} ${theme.lightBg} ${theme.text}` : 'border-gray-100 text-gray-400 hover:border-gray-200'}`}><div className="flex items-center justify-center gap-2"><Bone size={18}/> Botten</div></button>
                <button onClick={() => setTopic('muscles')} className={`p-3 rounded-xl font-bold border-2 transition-all ${topic === 'muscles' ? `${theme.border} ${theme.lightBg} ${theme.text}` : 'border-gray-100 text-gray-400 hover:border-gray-200'}`}><div className="flex items-center justify-center gap-2"><Activity size={18}/> Spieren</div></button>
              </div>
            </div>

            <div>
              <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Aantal vragen</label>
              <div className="flex justify-between bg-gray-100 p-1 rounded-xl">
                {[10, 15, 20].map(n => (
                  <button key={n} onClick={() => setCount(n)} className={`flex-1 py-2 rounded-lg text-sm font-bold transition-all ${count === n ? `bg-white shadow ${theme.text}` : 'text-gray-400'}`}>{n}</button>
                ))}
              </div>
            </div>

            <div>
              <label className="block text-xs font-bold text-gray-400 uppercase mb-1">Niveau (Kleur Piste)</label>
              <div className="grid grid-cols-1 gap-3">
                {[
                  { id: 'beginner', label: 'Beginner', desc: 'Nederlands kiezen', color: 'bg-green-500', hover: 'hover:bg-green-600', text: 'Groene Piste' },
                  { id: 'advanced', label: 'Gevorderd', desc: 'Latijn kiezen', color: 'bg-blue-500', hover: 'hover:bg-blue-600', text: 'Blauwe Piste' },
                  { id: 'specialist', label: 'Specialist', desc: 'Nederlands schrijven', color: 'bg-red-500', hover: 'hover:bg-red-600', text: 'Rode Piste' },
                  { id: 'expert', label: 'Expert', desc: 'Latijn schrijven', color: 'bg-gray-900', hover: 'hover:bg-gray-800', text: 'Zwarte Piste' }
                ].map((lvl) => (
                  <div key={lvl.id} className="relative group">
                    <button
                        onClick={() => setLevel(lvl.id as any)}
                        className={`w-full p-3 rounded-xl font-bold text-white transition-all flex justify-between items-center relative z-10 ${
                        level === lvl.id 
                            ? `${lvl.color} ring-4 ring-offset-2 ring-gray-200 scale-[1.02] shadow-lg` 
                            : `${lvl.color} opacity-90 hover:opacity-100 hover:scale-[1.01]`
                        }`}
                    >
                        <div className="flex flex-col items-start">
                        <span>{lvl.label}</span>
                        <span className="text-xs opacity-90 font-normal">{lvl.desc}</span>
                        </div>
                        <span className="text-xs uppercase opacity-80">{lvl.text}</span>
                    </button>
                    {/* Sticker Overlay */}
                    {(achievements as any)[lvl.id] && <AchievementSticker />}
                  </div>
                ))}
              </div>
            </div>
          </div>

          <button 
            onClick={startQuiz}
            className={`w-full mt-8 ${theme.button} text-white font-black text-lg py-4 rounded-xl shadow-lg hover:scale-[1.02] active:scale-95 transition-all flex items-center justify-center gap-2 relative z-20`}
          >
            START TRAINING <Play size={20} fill="white"/>
          </button>

          {/* Reset Button (Only if all complete) */}
          {allLevelsCompleted && (
              <button 
                onClick={resetProgress}
                className="mt-4 text-gray-400 text-xs font-bold hover:text-red-500 flex items-center justify-center gap-1 mx-auto transition-colors z-20 relative"
              >
                 <Trash2 size={12}/> BEGIN OPNIEUW
              </button>
          )}
        </div>
      </div>
    );
  }

  if (screen === 'quiz' || screen === 'meltdown') {
    const currentQ = questions[currentIdx];
    const progress = ((currentIdx) / questions.length) * 100;
    
    let questionText = "";
    let subHeader = "";
    let placeholder = "";

    switch (level) {
      case 'beginner': subHeader = "Wat is dit in het Nederlands?"; questionText = currentQ.la; break;
      case 'advanced': subHeader = "Wat is dit in het Latijn?"; questionText = currentQ.nl; break;
      case 'specialist': subHeader = "Wat is dit in het Nederlands?"; questionText = currentQ.la; placeholder = "Typ Nederlandse naam..."; break;
      case 'expert': subHeader = "Wat is dit in het Latijn?"; questionText = currentQ.nl; placeholder = "Typ Latijnse naam..."; break;
    }
    
    const meltdownOverlayStyle = isMelting ? { opacity: 1, pointerEvents: 'none' as const } : { opacity: 0, pointerEvents: 'none' as const };

    return (
      <div className={`min-h-screen ${theme.bg} flex flex-col items-center justify-center p-4 overflow-hidden relative transition-colors duration-500`}>
        <LavaOverlay active={isMelting} />
        <div className="fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-1000" style={meltdownOverlayStyle}>
           <h1 className="text-6xl md:text-9xl font-black text-white drop-shadow-lg tracking-tighter animate-bounce text-center">I'M MELTINGG!!!</h1>
        </div>

        <div className="w-full max-w-lg relative z-10">
          <div className="flex justify-between items-center mb-6 text-white font-bold">
            <div className="flex items-center gap-2"><span className="bg-white/20 px-3 py-1 rounded-full text-sm backdrop-blur-sm">V {currentIdx + 1}/{questions.length}</span></div>
            <div className="flex items-center gap-2"><Trophy size={18} /> {score}</div>
          </div>

          <div className="bg-white rounded-3xl shadow-[0_20px_50px_rgba(0,0,0,0.3)] p-8 relative min-h-[400px] flex flex-col">
            <Sticker type="hot" visible={streak >= 3 && streak < 5} />
            <Sticker type="super" visible={streak >= 5 && streak < 8} />
            <Sticker type="lava" visible={streak >= 8} />

            <div className="text-center mb-8 flex-1 flex flex-col justify-center">
              <h2 className="text-gray-400 font-bold uppercase tracking-widest text-xs mb-2">{subHeader}</h2>
              <h1 className={`text-4xl font-black ${theme.text} leading-tight transition-colors`}>{questionText}</h1>
            </div>

            {showFeedback && (
              <div className={`absolute inset-0 rounded-3xl z-10 flex items-center justify-center bg-opacity-90 backdrop-blur-sm transition-all ${showFeedback === 'correct' ? 'bg-green-100/90' : 'bg-red-100/90'}`}>
                <div className="text-center transform scale-110">
                  {showFeedback === 'correct' ? (
                    <>
                      <Check className="w-20 h-20 text-green-600 mx-auto mb-2" strokeWidth={3} />
                      <h3 className="text-3xl font-black text-green-800">GOED!</h3>
                    </>
                  ) : (
                    <>
                      <X className="w-20 h-20 text-red-600 mx-auto mb-2" strokeWidth={3} />
                      <h3 className="text-3xl font-black text-red-800">FOUT!</h3>
                      <p className="text-red-700 font-bold mt-2">{(level === 'beginner' || level === 'specialist') ? currentQ.nl : currentQ.la}</p>
                    </>
                  )}
                </div>
              </div>
            )}

            <div className="space-y-3">
              {(level === 'expert' || level === 'specialist') ? (
                <div className="relative">
                  <input type="text" value={inputVal} onChange={(e) => setInputVal(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleAnswer(inputVal)} placeholder={placeholder} autoFocus className={`w-full p-4 text-center text-xl font-bold border-2 rounded-xl focus:outline-none placeholder-gray-300 transition-all ${theme.border} ${theme.lightBg} ${theme.text} focus:border-opacity-100 border-opacity-20`} disabled={!!showFeedback} />
                  <button onClick={() => handleAnswer(inputVal)} className={`absolute right-2 top-2 bottom-2 ${theme.button} text-white px-4 rounded-lg font-bold transition-all`}>GA</button>
                </div>
              ) : (
                <div className="grid grid-cols-1 gap-3">
                  {options.map((opt, i) => (
                    <button key={i} onClick={() => handleAnswer(level === 'beginner' ? opt.nl : opt.la)} className={`w-full p-4 text-left font-bold border-2 rounded-xl transition-all active:scale-[0.98] ${theme.lightBg} ${theme.text} border-transparent hover:border-current hover:border-opacity-30`} disabled={!!showFeedback}>
                      <span className="inline-block w-8 opacity-50 mr-2">{String.fromCharCode(65 + i)}.</span>{level === 'beginner' ? opt.nl : opt.la}
                    </button>
                  ))}
                </div>
              )}
            </div>
          </div>
          <div className="mt-8 bg-black/20 rounded-full h-3 w-full overflow-hidden backdrop-blur-sm">
            <div className={`h-full transition-all duration-500 ease-out ${streak >= 8 ? 'bg-red-500' : streak >= 5 ? 'bg-yellow-400' : 'bg-white'}`} style={{ width: `${progress}%` }} />
          </div>
        </div>
      </div>
    );
  }

  if (screen === 'result') {
    const finalScore = score;
    const grade = parseFloat(getDutchGrade(finalScore, count));
    const passed = grade >= 5.5;

    return (
      <div className={`min-h-screen ${theme.bg} flex items-center justify-center p-4 transition-colors duration-500`}>
        <div className="bg-white rounded-3xl shadow-2xl p-8 max-w-md w-full text-center animate-in zoom-in duration-300">
          <div className={`mb-6 -mt-16 mx-auto bg-white rounded-full p-4 w-32 h-32 shadow-xl flex items-center justify-center border-8 ${theme.border.replace('border-', 'border-opacity-50 border-')}`}>
            {passed ? <div className="bg-green-500 w-full h-full rounded-full flex items-center justify-center"><Check size={64} className="text-white" strokeWidth={4} /></div> : <div className="bg-red-500 w-full h-full rounded-full flex items-center justify-center"><X size={64} className="text-white" strokeWidth={4} /></div>}
          </div>
          <h2 className="text-gray-400 font-bold uppercase tracking-widest text-sm mb-1">Resultaat</h2>
          <h1 className={`text-7xl font-black mb-2 ${passed ? 'text-green-600' : 'text-red-600'}`}>{grade}</h1>
          <p className={`${theme.text} font-bold text-xl mb-6`}>{getGradeText(grade)}</p>
          <div className={`${theme.lightBg} rounded-xl p-6 mb-8 relative`}>
            <div className="absolute -top-3 left-6 text-4xl">‚ùù</div>
            <p className={`${theme.text} font-medium italic relative z-10`}>{getFeedbackQuote(grade)}</p>
            {isMelting && <p className="text-xs text-red-500 font-bold mt-2 uppercase tracking-wide">System Meltdown Occurred</p>}
          </div>
          <div className="grid grid-cols-2 gap-4 mb-8 text-sm font-bold text-gray-600">
             <div className="bg-gray-50 p-3 rounded-lg"><span className="block text-xs text-gray-400 uppercase">Goed</span>{finalScore} / {questions.length}</div>
             <div className="bg-gray-50 p-3 rounded-lg"><span className="block text-xs text-gray-400 uppercase">Reeks</span>{streak} Max</div>
          </div>
          <button onClick={() => setScreen('setup')} className={`w-full ${theme.button} text-white font-black text-lg py-4 rounded-xl shadow-lg hover:scale-[1.02] active:scale-95 transition-all flex items-center justify-center gap-2`}>
            <RefreshCw size={20}/> OPNIEUW
          </button>
        </div>
      </div>
    );
  }
  return null;
}